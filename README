# My Novel Engine (プロジェクト名) - ドキュメント v1.0

`My Novel Engine`は、Phaser.jsをベースに構築された、柔軟で拡張性の高い、カスタムノベルゲームエンジンです。ノベルパートを中核としつつ、アクションゲームやパズルゲームなど、他のゲームジャンルとのシームレスな連携を目的として設計されています。

## 1. 基本設計思想

- **画面:** 横画面（1280x720）固定。`Phaser.Scale.FIT`モードにより、あらゆるデバイスでアスペクト比を維持して表示されます。
- **アセット管理:** `assets/asset_define.json`による一元管理。キャラクター画像はキーの命名規則により自動で定義されます。
- **シナリオ記述:** ティラノスクリプト風のタグを使った、可読性の高いシナリオファイル（`.ks`）方式を採用。
- **モジュール設計:** 機能ごとにクラスやファイルが分離されており、高いメンテナンス性と拡張性を持ちます。
- **シーン管理:** `SystemScene`を司令塔とした、イベント駆動型の柔軟なシーン遷移アーキテクチャを採用。

## 2. プロジェクトの始め方

1.  **アセットの準備:**
    -   `assets/` フォルダ内に、画像、音声、動画、シナリオ（`.ks`）ファイルを配置します。
2.  **`asset_define.json`の編集:**
    -   ゲーム起動時に読み込む**共通アセット**を登録します。
3.  **シナリオの記述:**
    -   `assets/scene1.ks`をゲームの開始点とし、各シナリオファイルにタグを使って物語を記述します。
    -   特定のシナリオファイルでしか使わないアセットは、その`.ks`ファイルの先頭で`@asset`ディレクティブを使って**動的ロード**を宣言します。
4.  **ブラウザで確認:**
    -   ローカルサーバー（Live Serverなど）を起動し、`index.html`にアクセスして動作を確認します。

---

## 3. アセット定義

### 3.1. 共通アセット (`asset_define.json`)

ゲーム全体で共有する基本的なアセットを登録します。

- **`images`**: UI画像、頻繁に使う背景やキャラクターなど。
  - **キャラクターの自動定義:** キーを`"キャラクター名_表情名"`とすることで、自動的にキャラクターとしてエンジンに登録されます。（例: `"yuna_normal"`）
- **`sounds`**: 共通のSEやBGM。
- **`videos`**: 共通の動画素材。

### 3.2. 動的ロードアセット (各`.ks`ファイル)

特定のシナリオでのみ使用するアセットは、そのシナリオファイルの先頭で`@asset`ディレクティブを使って宣言します。これにより、ゲーム起動時のロード時間を短縮できます。

**書式:** `@asset type=[種類] key=[キー] path=[パス]`
Use code with caution.
Markdown
; scene2.ks の冒頭
@asset type=image key=cg_secret path=assets/cg_secret.jpg
@asset type=audio key=se_surprise path=assets/se/surprise.wav

Generated code
- `type`: `image`, `audio`, `video`などを指定。
- `key`: このアセットを呼び出すためのユニークな名前。
- `path`: `assets/`からのファイルパス。

---

## 4. 主要タグ一覧

（※このセクションには、あなたが以前確認した、フロー制御、テキスト、キャラクター、演出、サウンド、変数に関する全てのタグの詳細な説明が入ります。ここでは代表的なものを抜粋します。）

| カテゴリ | タグ | 機能 |
| :--- | :--- | :--- |
| **フロー制御** | `[if]`, `[jump]`, `[call]`, `[return]`, `[s]` | 条件分岐、ジャンプ、別シナリオ/シーンの呼び出しと復帰、シナリオ停止。 |
| **テキスト** | `[p]`, `[cm]`, `[br]`, `[delay]` | クリック待ち、メッセージクリア、強制改行、テキスト速度変更。 |
| **キャラクター** | `[chara_show]`, `[chara_mod]`, `[chara_hide]` | 表示、表情変更、非表示。`pos`属性で立ち位置指定。 |
| **動的演出** | `[move]`, `[walk]`, `[shake]`, `[flip]` | 移動、歩行、振動、反転など多彩なアニメーション。`nowait`, `loop`属性で制御可能。 |
| **サウンド** | `[playbgm]`, `[stopbgm]`, `[playse]` | BGMとSEの再生・停止。 |
| **システム** | `[eval]`, `[save]`, `[load]`, `[overlay_end]` | 変数操作、セーブ/ロード、オーバーレイ終了。 |

---

## 5. シーン連携 (最重要)

このエンジンの最大の特徴は、柔軟なシーン遷移機能です。司令塔である**`SystemScene`**を介して、すべての遷移を管理します。

### 5.1. 別ゲームシーンの呼び出し

ノベルパートからアクションゲームなどを呼び出し、終わったら元のシナリオの続きに戻ります。

**`GameScene`側 (シナリオ):**
`[call storage="ActionScene"]`

**`ActionScene`側 (終了時):**
`this.scene.get('SystemScene').events.emit('return-to-novel', { from: 'ActionScene', params: { 'f.result': 'win' } });`

### 5.2. ゲーム画面上へのオーバーレイ表示

動き続けているゲーム画面の上に、ノベルパートを重ねて表示します。

**`ActionScene`側 (呼び出し):**
`this.scene.get('SystemScene').events.emit('request-overlay', { from: 'ActionScene', scenario: 'overlay_test.ks' });`

**オーバーレイシナリオ側 (終了時):**
`[overlay_end]`
